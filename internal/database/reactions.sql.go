// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: reactions.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const deleteOldStats = `-- name: DeleteOldStats :exec
DELETE from posts_reactions_history
where
    synced_at < now() - INTERVAL '14 days'
`

func (q *Queries) DeleteOldStats(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteOldStats)
	return err
}

const getDailyStats = `-- name: GetDailyStats :many
SELECT
    s.id,
    s.network,
    s.user_name,
    DATE (p.created_at) as date,
    SUM(prh.likes) as total_likes,
    SUM(prh.reposts) as total_reposts
FROM
    posts_reactions_history prh
    JOIN posts p ON prh.post_id = p.id
    JOIN sources s ON p.source_id = s.id
WHERE
    s.user_id = $1
    AND prh.synced_at = (
        SELECT MAX(synced_at)
        FROM posts_reactions_history
        WHERE
            post_id = prh.post_id
            AND DATE (synced_at) = DATE (prh.synced_at)
    )
    AND p.post_type <> 'repost'
GROUP BY
    s.id,
    s.network,
    s.user_name,
    DATE (prh.synced_at),
    DATE (p.created_at)
ORDER BY s.id, date ASC
`

type GetDailyStatsRow struct {
	ID           uuid.UUID
	Network      string
	UserName     string
	Date         time.Time
	TotalLikes   int64
	TotalReposts int64
}

func (q *Queries) GetDailyStats(ctx context.Context, userID uuid.UUID) ([]GetDailyStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDailyStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyStatsRow
	for rows.Next() {
		var i GetDailyStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Network,
			&i.UserName,
			&i.Date,
			&i.TotalLikes,
			&i.TotalReposts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyStats = `-- name: GetWeeklyStats :many
WITH
    LatestStats AS (
        SELECT prh.post_id, prh.likes, prh.reposts
        FROM
            posts_reactions_history prh
            JOIN (
                SELECT post_id, MAX(synced_at) as max_sync
                FROM posts_reactions_history
                GROUP BY
                    post_id
            ) latest ON prh.post_id = latest.post_id
            AND prh.synced_at = latest.max_sync
    )
SELECT
    s.id,
    s.network,
    s.user_name,
    TO_CHAR(p.created_at, 'IYYY-IW') as year_week,
    COALESCE(SUM(ls.likes), 0)::bigint as total_likes,
    COALESCE(SUM(ls.reposts), 0)::bigint as total_reposts
FROM
    posts p
    JOIN sources s ON p.source_id = s.id
    JOIN LatestStats ls ON p.id = ls.post_id
WHERE
    s.user_id = $1
    AND p.post_type <> 'repost'
GROUP BY
    s.id,
    s.network,
    s.user_name,
    year_week
ORDER BY year_week ASC
`

type GetWeeklyStatsRow struct {
	ID           uuid.UUID
	Network      string
	UserName     string
	YearWeek     string
	TotalLikes   int64
	TotalReposts int64
}

func (q *Queries) GetWeeklyStats(ctx context.Context, userID uuid.UUID) ([]GetWeeklyStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, getWeeklyStats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWeeklyStatsRow
	for rows.Next() {
		var i GetWeeklyStatsRow
		if err := rows.Scan(
			&i.ID,
			&i.Network,
			&i.UserName,
			&i.YearWeek,
			&i.TotalLikes,
			&i.TotalReposts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const syncReactions = `-- name: SyncReactions :one
INSERT INTO
    posts_reactions_history (
        id,
        synced_at,
        post_id,
        likes,
        reposts,
        views
    )
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (
    post_id,
    (CAST(synced_at AS DATE))
) DO
UPDATE
SET
    likes = EXCLUDED.likes,
    reposts = EXCLUDED.reposts,
    views = EXCLUDED.views,
    synced_at = EXCLUDED.synced_at
RETURNING
    id, synced_at, post_id, likes, reposts, views
`

type SyncReactionsParams struct {
	ID       uuid.UUID
	SyncedAt time.Time
	PostID   uuid.UUID
	Likes    sql.NullInt32
	Reposts  sql.NullInt32
	Views    sql.NullInt32
}

func (q *Queries) SyncReactions(ctx context.Context, arg SyncReactionsParams) (PostsReactionsHistory, error) {
	row := q.db.QueryRowContext(ctx, syncReactions,
		arg.ID,
		arg.SyncedAt,
		arg.PostID,
		arg.Likes,
		arg.Reposts,
		arg.Views,
	)
	var i PostsReactionsHistory
	err := row.Scan(
		&i.ID,
		&i.SyncedAt,
		&i.PostID,
		&i.Likes,
		&i.Reposts,
		&i.Views,
	)
	return i, err
}
